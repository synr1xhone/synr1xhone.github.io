---
title: 'GServe: My Personal Server'
date: 2024-5-21
toc: true
toc_sticky: true
toc_label: "Table of Contents"
categories:
  - blog 
tags:
  - Server
  - Debian
  - Docker
  - Networking
  - Sysadmin
---

# Introduction/Background

## How it all started

I have always been a fan of self-hosting services. For years I have been running a Jellyfin server on my Windows laptop, we well as a VPN and DNS server on my Raspberry Pi. However, I have always wanted to have a dedicated server to host all my services, something that is powerful enough to run multiple services at once (in Docker containers) and low power enough to leave running in the basement in my house. 

I have been looking at various options for a while, including a Raspberry Pi 4, a NUC, and a [HP elitedesk 800 g4](https://support.hp.com/us-en/document/c06045012) that many tech YouTubers have been recommending. However, the price tag for a beefy enough machine was always a little too high for me (the cheapest option being $100+).

This is until recently my good friend/roommate GHigh (whose name is also George) broke his laptop screen and decided to buy a new one. He was kind enough to give me his old laptop, an HP ENVY x360 laptop (neofetch output below). 
  
```bash
       _,met$$$$$gg.          george@gserver
    ,g$$$$$$$$$$$$$$$P.       --------------
  ,g$$P"     """Y$$.".        OS: Debian GNU/Linux 12 (bookworm) x86_64
 ,$$P'              `$$$.     Host: HP ENVY x360 2-in-1 Laptop 15-ew0xxx
',$$P       ,ggs.     `$$b:   Kernel: 6.1.0-21-amd64
`d$$'     ,$P"'   .    $$$    Uptime: 5 mins
 $$P      d$'     ,    $$P    Packages: 1639 (dpkg)
 $$:      $$.   -    ,d$$'    Shell: bash 5.2.15
 $$;      Y$b._   _,d$P'      Resolution: 1920x1080
 Y$$.    `.`"Y$$$$P"'         Terminal: /dev/pts/0
 `$$b      "-.__              CPU: 12th Gen Intel i7-1255U (12) @ 4.700GHz
  `Y$$                        GPU: Intel Alder Lake-UP3 GT2 [Iris Xe Graphics]
   `Y$$.                      Memory: 1118MiB / 15704MiB
     `$$b.
       `Y$$b.
          `"Y$b._
              `"""
```

With the 12th Gen Intel i7 as well as Iris Xe Graphics, this laptop should be more than capable of running Jellyfin with multiple transcodes, as well as other services, which is my goal for this server. It should also be pretty power efficient since it's a laptop with recent hardware.

## The Plan

Currently I would like to run the following services on this server:

- Jellyfin
- VPN
- DNS

I would also like to have the following features:

- Reverse Proxy
- Dynamic DNS
- Monitoring

I'll be using Docker to run all these services, as it is the easiest way to manage multiple services on a single machine. As for operating system, I'll be using Debian as the host OS, as it is the most stable and secure OS for servers.

# Initial Setup

## Installing Debian

I was able to find a detailed instruction on how to install Debian on the laptop from [a guide from WikiHow](https://www.wikihow.com/Install-Debian). I followed it exactly and it worked perfectly. Looking back, one thing I might want to change is I wouldn't have install the Gnome desktop environment, as I won't be using it much and would like to save some resources. But it wouldn't be a big deal since I can always just disable DE from starting up.

## Basic Networking

Being a Networking Guru (many thanks to [Prof. Parviz Kermani](https://www.cics.umass.edu/people/kermani-parviz)), I know that it is important to assign a static IP address to the server, since that's how computers talk to each other. The command is simple:

```bash
sudo ip addr add <IP Address>/<Subnet Mask> dev <Interface>
```

Now I can just SSH into the server using the static IP address assigned and work on it remotely.

## Turning off the Screen

Since this is a server, I don't need the screen to be on all the time. I found [a very good guide](https://www.dwarmstrong.org/laptop-home-server/) from Daniel Wayne Armstrong's website, where he gave a few options. I tried the "vbetool" command in the "2.5 Turn off backlight" section, but it throws an error `Real mode call failed` and I am not able to turn off the screen. However, his suggestion to edit the `/etc/systemd/logind.conf` file and change all the `#HandleLidSwitch=suspend` to `HandleLidSwitch=ignore` worked for my purpose, which allowed me to close the lid to turn off the screen without suspending the system. 

## Preventing the Laptop from Sleeping

Another issue arose when I was editing this document, where the SSH session would disconnect after receiving a broadcast message `Broadcast message... The system will suspend now!`. This is annoying because I would like the server to be always on regardless of user activity. Luckily, after hours of Googling, I was able to find a solution from the [Debian Forum](https://forums.debian.net/viewtopic.php?t=156005), where they suggested to edit the `/etc/systemd/logind.conf` file and change the `#AllowSuspend=yes` to `AllowSuspend=no`. After this change the server hasn't gone to sleep since.

## Showing battery status

On the top right of Gnome Desktop there is a battery status icon as well as remaining battery percentage. Since I won't be using the desktop environment, I would like to have a way to check the battery status from the terminal. I found an article from the [Linux Journal](https://www.linuxjournal.com/content/how-check-battery-status-using-linux-command-line) that allows me to check the battery status using the `upower` command. I made a file called "battery" that allow me to check the battery status with a single command.

```bash
12:31 AM -> george at -bash in ~/useful
$ cat battery
#!/usr/bin/env sh
upower -i $(upower -e | grep BAT) | grep --color=never -E "state|to\ full|to\ empty|percentage"

12:38 AM -> george at -bash in ~/useful
$ ./battery
    state:               charging
    time to full:        3.2 minutes
    percentage:          99%
```

# Setting up Jellyfin in Docker

Jellyfin is a FOSS (Free and Open Source Software) media server that allows you to host your own media library. It has an interface that looks similar to Netflix, but I can fill it with "my own" media and access it from my phone, laptop, or TV. I can also set up multiple accounts to share with friends and family. 

![Jellyfin Home Page](/assets/images/blog_images/gserve/jellyfin-home.png)

I have been running Jellyfin on my Windows Laptop for a while, but it requires my laptop to be on and connected to the external drives that I use (an external HDD and a high capacity SD card), which is not ideal. Now that I have this laptop, I can easily leave Jellyfin running on it and external drives plugged in.

## Setting up Docker

I followed the [official Docker installation guide](https://docs.docker.com/engine/install/debian/) to install Docker on the server. I also installed Docker Compose using the [official guide](https://docs.docker.com/compose/install/). Once that's done, I was able to run the following command to check if Docker is installed correctly:

```bash
11:20 PM -> george at -bash in ~
$ docker --version
Docker version 26.1.3, build b72abbb

11:20 PM -> george at -bash in ~
$ docker compose

Usage:  docker compose [OPTIONS] COMMAND

Define and run multi-container applications with Docker
```

## Setting up Jellyfin

I found the official Jellyfin Docker image on [Docker Hub](https://hub.docker.com/r/jellyfin/jellyfin). I created a `docker-compose.yml` file in the `/srv/jellyfin` directory with the following content:

```yaml
services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
      #user: uid:gid
      #network_mode: 'host'
    ports:
      - "<local port>:8096"
    volumes:
      - jellyfin-config:/config
      - jellyfin-cache:/cache
      - type: bind
        source: <local location>
        target: <mirroring folder in container (will be created by Docker)>
          #read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=<public IP>:<local port>

volumes:
  jellyfin-config:
  jellyfin-cache:
```

For this to work, we need to first create the volumes by running the following command:

```bash
sudo docker volume create jellyfin-config
sudo docker volume create jellyfin-cache
```

Then we can run the following command to start the Jellyfin container:

```bash
sudo docker-compose -f /srv/jellyfin/docker-compose.yml up -d
```

Now I can access Jellyfin by going to `http://<public IP>:<local port>` in my browser. I can also access it from my phone by downloading the Jellyfin app and entering the same address.


# Setting up Port Forwarding and Dynamic DNS

## Setting up Port Forwarding

This is the most important step in setting up a server, as it allows the server to be accessed from the outside world. To explain it simply, when a computer is connected to a network through Wifi or Ethernet, it is connected to a private network, in which it is given an IP address that is used by other computers in the private network to talk to it. However, for a computer to communicate with a computer outside of the private network, it uses a technology called NAT (network address translation) where the router "translates" the private IP addresses of the computers in the private network to its own public IP address and does all the communication on behalf of the computers. However, this means computers outside the private network cannot initiate communication with computers inside the private network. This is where port forwarding comes in. By setting up port forwarding on the router, we can tell the router to forward all the traffic coming to a specific port on the public IP address to a specific computer in the private network. 

However, there is no specific instruction I can give you guys, as every router is different. I would recommend you to look up the model of your router and search for "port forwarding" in the manual. What I did is forward ports like 22 (SSH), 80 (HTTP), 443 (HTTPS), and 8096 (Jellyfin) to the server's IP address. A good practice is to use non-standard ports for services like SSH to avoid brute force attacks, but some might also argue that port scanning can easily find the non-standard ports so it doesn't really matter. I just did it for the extra peace of mind.

## Setting up Dynamic DNS

The problem with port forwarding is that the public IP address of the router can change, especially if you are using a residential internet connection. This means that the public IP address that you set up the port forwarding for might not be the same in a few days. This is where Dynamic DNS comes in. Dynamic DNS is a service that allows you to assign a domain name to your public IP address, and it will automatically update the domain name to point to the new public IP address when it changes. 

For this, I used [DuckDNS](https://www.duckdns.org/), a free Dynamic DNS service. I created an account and set up a domain name, and followed the instructions to set up the DuckDNS client on the server. They have a web page that shows you exactly what commands to run on the server to have it update the domain name every 5 minutes [here](https://www.duckdns.org/install.jsp), which I followed on my server.

# QBittorrent and OpenVPN in Docker

To be continued...
